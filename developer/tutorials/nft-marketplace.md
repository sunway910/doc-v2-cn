åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæ‚¨å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨ ink! åœ¨ CESS ä¸Šæ„å»ºä¸€ä¸ª NFT äº¤æ˜“å¹³å°çš„åŸºç¡€æµç¨‹ã€‚æ‚¨å°†ç¼–å†™ä¸€ä¸ªink! æ™ºèƒ½åˆçº¦ï¼Œä¸ºä¸Šä¼ åˆ° CESS ç½‘ç»œçš„æ–‡ä»¶é“¸é€  NFT ä»£å¸ã€‚é“¸é€  NFT åï¼Œç”¨æˆ·å¯ä»¥é€‰æ‹©å°†å…¶ NFT ä»£å¸ä¸Šæ¶æˆ–ä¸‹æ¶ã€‚å› æ­¤åœ¨å¼€å§‹ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆäº†è§£ä¸€ä¸‹ NTF å’Œ CESSã€‚å¦‚æœæ‚¨å·²ç»äº†è§£ NFT å’Œ CESSï¼Œå¯ä»¥ç›´æ¥è·³åˆ° NFT äº¤æ˜“å¹³å°æ¶æ„çš„éƒ¨åˆ†è¿›è¡Œé˜…è¯»ã€‚

{% hint style="warning" %}

ğŸ’¡ æ¸©é¦¨æç¤ºï¼šæœ¬æ•™ç¨‹ç¯‡å¹…è¾ƒé•¿ã€‚ä½†å¦‚æœæ‚¨ç¡®å®æƒ³äº†è§£å¦‚ä½•åˆ›å»ºè‡ªå·±çš„ NFT äº¤æ˜“å¹³å°ï¼Œé‚£ä¹ˆèŠ±æ—¶é—´é˜…è¯»æœ¬æ•™ç¨‹å°†ä¼šä¸ºæ‚¨å¸¦æ¥ä¸€å®šæ”¶è·ã€‚

{% endhint %}

# ä»€ä¹ˆæ˜¯ NFTï¼Ÿ

åœ¨æˆ‘ä»¬äº†è§£ä»€ä¹ˆæ˜¯ NFTï¼ˆéåŒè´¨åŒ–ä»£å¸ï¼‰ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£åŒè´¨åŒ–ä»£å¸ã€‚åŒè´¨åŒ–ä»£å¸æ˜¯å¯ä»¥äº’æ¢çš„ï¼Œå°±åƒç¾å…ƒæˆ–æ¯”ç‰¹å¸ä¸€æ ·ï¼Œå®ƒä»¬çš„ä»·å€¼åœ¨ä»»ä½•åœ°æ–¹éƒ½ä¿æŒä¸å˜ã€‚ä¾‹å¦‚ï¼Œå¯¹äºå®ç‰©è´§å¸é’ç¥¨ï¼Œæ‚¨å¯ä»¥å°†ä¸€å¼  10 ç¾å…ƒé’ç¥¨å…‘æ¢æˆå¦ä¸€å¼  10 ç¾å…ƒé’ç¥¨ï¼Œå…¶ä»·å€¼ä¿æŒä¸å˜ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒåŒè´¨åŒ–ä»£å¸å¯ä»¥äº’æ¢å› å…¶ä¸¤ä¸ªå€¼ç›¸åŒã€‚

å¦ä¸€æ–¹é¢ï¼ŒéåŒè´¨åŒ–ä»£å¸ä¸å¯äº’æ¢ã€‚ä¾‹å¦‚ï¼ŒåœŸåœ°è´¢äº§æ˜¯ä¸å¯æ›¿ä»£çš„ï¼Œå› ä¸ºä¸¤å—åœŸåœ°ä¸å¤ªå¯èƒ½å…·æœ‰ç›¸åŒçš„ä»·å€¼ã€‚å®ƒä»¬å¯èƒ½æ‹¥æœ‰ä½¿åœŸåœ°å…·æœ‰ä¸åŒçš„ä»·å€¼çš„å› ç´ å¦‚è‡ªç„¶èµ„æºã€‚

åœ¨åŒºå—é“¾ä¸­ï¼ŒåŒè´¨åŒ–ä»£å¸è¢«ç§°ä¸º ERC-20 ä»£å¸ï¼Œæ˜¯ç”±ä»¥å¤ªåŠåŸºé‡‘ä¼šåˆ›å»ºçš„æ ‡å‡†æ ¼å¼ã€‚ERC-20 ä»£å¸çš„ä¸€äº›ç¤ºä¾‹åŒ…æ‹¬æ¯”ç‰¹å¸ (BTC)ã€Tether (USDT) ç­‰ã€‚å…¶ä¸­éåŒè´¨åŒ–ä»£å¸æ˜¯ä½¿ç”¨ [ERC-721](https://docs.openzeppelin.com/contracts/4.x/erc721) ä»£å¸æ ‡å‡†åˆ›å»ºçš„ï¼Œè¯¥æ ‡å‡†æ‰¿è®¤ä»£å¸æ‰€æœ‰æƒã€‚ä¸æ­¤ç±»ä¼¼çš„æ˜¯ç”¨ [ink!](https://use.ink/) å†™çš„ [PSP34 æ ‡å‡†](https://github.com/w3f/PSPs/blob/master/PSPs/psp-34.md)ã€‚è¯¥æ ‡å‡†ç”¨äºå­˜å‚¨åŒºå—é“¾ä¸­ä»£å¸/æ”¶è—å“çš„æ‰€æœ‰æƒï¼Œè€Œè¿™äº›æ”¶è—å“å¯ä»¥æ˜¯æ‰€æœ‰æƒå¥‘çº¦ã€åœŸåœ°ã€è‰ºæœ¯å“ã€è§†é¢‘ã€å›¾åƒç­‰ä»»ä½•ä¸œè¥¿ã€‚

# ä»€ä¹ˆæ˜¯ CESSï¼Ÿ

CESSï¼ˆCumulus Encrypted Storage Systemï¼‰æ˜¯åŸºäºåŒºå—é“¾çš„å»ä¸­å¿ƒåŒ–äº‘å­˜å‚¨ç½‘ç»œå’Œ CDN ç½‘ç»œï¼Œæ”¯æŒæ•°æ®åœ¨çº¿å­˜å‚¨å’Œå®æ—¶å…±äº«ï¼Œä¸º Web3 é«˜é¢‘åŠ¨æ€æ•°æ®çš„å­˜å‚¨å’Œæ£€ç´¢æä¾›å…¨æ ˆè§£å†³æ–¹æ¡ˆã€‚CESS æ•°æ®ä»·å€¼ç½‘ç»œæ˜¯ä»¥ DePIN ç†å¿µå»ºè®¾çš„ Layer 1 åŸºç¡€è®¾æ–½ï¼Œå…·æœ‰å»ä¸­å¿ƒåŒ–ï¼Œé«˜æ•ˆï¼Œå®‰å…¨éšç§å’Œå¯æ‰©å±•ç­‰ç‰¹æ€§ã€‚

CESS æä¾›äº† SDK å’Œ RESTful APIï¼Œå³å¯ä»¥é€šè¿‡ CESS ç½‘ç»œçš„ç½‘å…³ä¸Šä¼ å’Œä¸‹è½½æ–‡ä»¶ï¼Œè€Œæ— éœ€æ‹…å¿ƒæ˜¯å¦å¯¹ CESS æ–‡ä»¶åˆ†å‘çš„åº•å±‚æœºåˆ¶æœ‰æ·±åº¦äº†è§£ã€‚æ‚¨å¯ä»¥ç‚¹å‡»[æ­¤å¤„](https://docs.cess.cloud/cess-wiki/introduction/overview)äº†è§£æœ‰å…³ CESS çš„æ›´å¤šä¿¡æ¯ã€‚

# NFT äº¤æ˜“å¹³å°æ¶æ„

![CESS NFT äº¤æ˜“å¹³å°](../../assets/developer/tutorials/nft-marketplace/cess-marketplace.png)

ä¸Šå›¾æè¿°äº† NFT äº¤æ˜“å¹³å°æ‰€æ¶‰åŠçš„æ‰€æœ‰ç»„ä»¶çš„æ•´ä½“æµç¨‹ã€‚ç”¨æˆ·ç«¯åº”ç”¨ç¨‹åºç”±é’±åŒ…å’Œå¸‚åœº/å¹³å°ç»„æˆï¼Œç”¨æˆ·å¯ä»¥åœ¨å…¶ä¸­ä»¥ NFT å½¢å¼ä¹°å–èµ„äº§ã€‚æ‚¨è¿˜éœ€è¦ä¸€ä¸ªåŸºäº PSP34 æ ‡å‡†çš„æ™ºèƒ½åˆçº¦æ¥å®ç°ä»£å¸æ‰€æœ‰æƒç¡®ç«‹ã€NFT çš„è´­ä¹°å’Œé”€å”®ã€‚ä¸ºäº†æœ¬æ•™ç¨‹çš„ç®€æ´å’Œé‡ç‚¹ä»‹ç»ï¼Œæˆ‘ä»¬è®²ä¸»è¦å…³æ³¨å¦‚ä½•åœ¨ CESS ä¸Šåˆ›å»º NFT å¸‚åœºçš„åŸºæœ¬ç†å¿µï¼Œä¸ä¼šæ¶‰åŠç®¡ç†ç”¨æˆ·ç§¯åˆ†å¥–åŠ±å’Œåå°ç®¡ç†çš„ç›¸å…³å†…å®¹ã€‚å¦‚éœ€äº†è§£ä¸€ä¸ªå®Œæ•´çš„ NFT åº”ç”¨ç¨‹åºçš„æ•´ä½“æµç¨‹ï¼Œè¯·ç»§ç»­é˜…è¯»ä»¥ä¸‹å†…å®¹ã€‚

å‰ç«¯åº”ç”¨ç¨‹åºåˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œç”¨æˆ·ç«¯åº”ç”¨ç¨‹åºå’Œç®¡ç†åå°ã€‚ ç®¡ç†åå°å°†æœ‰æƒä»æ™ºèƒ½åˆçº¦ä¸­å­˜å…¥æˆ–æå–ä»£å¸ï¼Œè¿™äº›ä»£å¸å°†åœ¨ç”¨æˆ·å…‘æ¢å¥–åŠ±ç§¯åˆ†æ—¶æ¶ˆè€—ï¼Œæˆ‘ä»¬ç§°å…¶ä¸ºå›½åº“éƒ¨ä»½ã€‚ ç®¡ç†åå°è¿˜æœ‰èƒ½åŠ›ç®¡ç†ç”¨æˆ·ç§¯åˆ†å¥–åŠ±ï¼›å¦ä¸€éƒ¨åˆ†ï¼Œç”¨æˆ·å°†ä»ç”¨æˆ·ç«¯åº”ç”¨ç¨‹åºè·å– CESS ä»£å¸å¼€å§‹ä½¿ç”¨ NFT äº¤æ˜“å¹³å°ã€‚æ”¶åˆ°ä¸€äº›ä»£å¸åï¼Œç”¨æˆ·å¯ä»¥ç»§ç»­è´­ä¹°ç©ºé—´æˆ–ç´¢å–é€šè¿‡æ¨èè®¡åˆ’è·å¾—çš„ç©ºé—´ã€‚ä¸€æ—¦ç”¨æˆ·çš„å¸æˆ·æœ‰ä¸€äº›å¯ç”¨ç©ºé—´ï¼Œä»–ä»¬å°±å¯ä»¥åœ¨ CESS ç½‘ç»œä¸Šä¸Šä¼ èµ„äº§ï¼ˆå›¾åƒã€è§†é¢‘ã€éŸ³é¢‘ç­‰ï¼‰ã€‚å¦‚éœ€åˆ›å»º NFTï¼Œç”¨æˆ·é¦–å…ˆéœ€è¦å°†å…¶ NFT èµ„äº§ä¸Šä¼ åˆ° CESSï¼Œå¹¶å°†åŒ…å« NFT æ‰€æœ‰æƒå…ƒæ•°æ®çš„äº¤æ˜“å‘é€åˆ° CESS åŒºå—é“¾ã€‚äº¤æ˜“ç¡®è®¤åï¼Œä»–ä»¬ç°åœ¨å¯ä»¥å°†å…¶ NFT æŒ‚ç‰Œå‡ºå”®/ç§Ÿèµæˆ–èµ é€ç»™ä»»ä½•å…¶ä»–ç”¨æˆ·ã€‚

ç”¨æˆ·å¯ä»¥é€šè¿‡ç”¨æˆ·ç«¯åº”ç”¨ç¨‹åºè®¿é—® NFT å¸‚åœºï¼Œå¹¶æŸ¥çœ‹æ‰€æœ‰åˆ—å‡ºçš„å¯ä¾›è´­ä¹°æˆ–ç§Ÿèµçš„ NFTã€‚è¦è´­ä¹° NFTï¼Œä»–ä»¬çš„é’±åŒ…è´¦æˆ·ä¸­éœ€è¦æœ‰è¶³å¤Ÿçš„ä»£å¸ã€‚å¯¹äºæ¯æ¬¡è´­ä¹°ï¼Œæ ¹æ®åº”ç”¨ç¨‹åºçš„é…ç½®ï¼Œç”¨æˆ·å¯ä»¥è·å¾—ä¸€å®šæ•°é‡çš„å¥–åŠ±ç§¯åˆ†ã€‚å¥–åŠ±ç§¯åˆ†å¯ä»¥ç”¨äºåœ¨ä¸‹æ¬¡è´­ä¹°æ—¶è¿›è¡Œå…‘æ¢ã€‚æ¯å½“ç”¨æˆ·å…‘æ¢å¥–åŠ±ç§¯åˆ†æ—¶ï¼Œå‰©ä½™é‡‘é¢å°†ä»é‡‘åº“ä¸­è¿”è¿˜ç»™å–å®¶ã€‚ä¸€æ—¦æ‰€æœ‰æƒè½¬ç§»ç»™å¦ä¸€ä¸ªç”¨æˆ·ï¼Œå…³è”çš„æ–‡ä»¶ä¹Ÿä¼šç§»åŠ¨åˆ°æ–°æ‰€æœ‰è€…çš„å­˜å‚¨ç©ºé—´ã€‚

{% hint style="info" %}
æ¸©é¦¨æç¤ºï¼šç”±äºæœ¬æ•™ç¨‹ä¸»è¦å…³æ³¨ NFT å¸‚åœºçš„åŸºæœ¬åŠŸèƒ½ã€‚ç¯‡å¹…æœ‰é™ï¼Œæˆ‘ä»¬ä¸ä¼šå®ç°ä¸Šé¢æåˆ°çš„æ‰€æœ‰åŠŸèƒ½ã€‚
{% endhint %}

# å¦‚ä½•åˆ›å»º NFTï¼Ÿ

åˆ›å»º NFT éœ€è¦é€‰æ‹©æˆ‘ä»¬æƒ³è¦è¿›è¡Œ NFT åŒ–çš„èµ„äº§ã€‚ä¾‹å¦‚ï¼Œä¸€ä»¶å›¾åƒè‰ºæœ¯å“å¯ä»¥è¢«é“¸é€ ä¸º NFTã€‚æˆ‘ä»¬å°†ä½¿ç”¨ CESS ç½‘ç»œæ¥å­˜å‚¨æˆ‘ä»¬çš„èµ„äº§ã€‚èµ„äº§å¯ä»¥æ˜¯è§†é¢‘ã€å›¾åƒã€éŸ³é¢‘ç­‰ä»»ä½•å†…å®¹ï¼Œæ‰€ç”Ÿæˆçš„èµ„äº§çš„ JSON å…ƒæ•°æ®å°†è®°å½•åœ¨åœ¨ CESS åŒºå—é“¾ä¸Šã€‚

è¯·æ³¨æ„ï¼Œæˆ‘ä»¬ä¸ä¼šå°†èµ„äº§æ•°æ®æœ¬èº«å­˜å‚¨åœ¨åŒºå—é“¾ä¸­ï¼Œè€Œæ˜¯å­˜å‚¨å…¶å…ƒæ•°æ®ã€‚è¿™æ˜¯å› ä¸ºå°†æ–‡ä»¶æœ¬èº«å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šä¼šä½¿åŒºå—é“¾å˜å¾—è‡ƒè‚¿ï¼Œä½¿æ‰€æœ‰èŠ‚ç‚¹éƒ½ä¸‹è½½æˆ‘ä»¬çš„èµ„äº§ï¼Œè¿™ä¸ä»…ä¼šå¢åŠ æˆ‘ä»¬çš„æˆæœ¬ï¼Œè€Œä¸”ä¼šä¸å¿…è¦åœ°åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸Šå¤åˆ¶æˆ‘ä»¬çš„èµ„äº§ã€‚

NFT è¢«åˆ†é…äº†ä¸€ä¸ªå”¯ä¸€çš„ IDï¼Œæˆ‘ä»¬å°†åœ¨é“¸é€ æ–°çš„ NFT æ—¶é€’å¢è¯¥ IDã€‚æˆ‘ä»¬å°†ä½¿ç”¨ `last_token_id`æ¥è·Ÿè¸ªæœ€åé“¸é€ çš„ä»£å¸ IDã€‚

```rust
#[openbrush::storage_item]
pub struct NftData {
    pub last_token_id: u64,
    pub collection_id: u32,
    pub max_supply: u64,
    pub price_per_mint: Balance,
    pub fid_list: Mapping<Id, String>,
    pub sale_list: Mapping<Id, Balance>,
}
```

å½“æˆ‘ä»¬å°†æ–‡ä»¶ä¸Šä¼ åˆ° CESS ç½‘ç»œæ—¶ï¼Œæˆ‘ä»¬ä¼šæ”¶åˆ°ä¸€ä¸ªæ–‡ä»¶ ID (fid)ã€‚ç”±äºè¯¥ fid å¯¹äº CESS ç½‘ç»œæ¥è¯´æ˜¯å”¯ä¸€çš„ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†å…¶ç”¨ä½œåˆçº¦çš„ TokenIDã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨ fid ä½œä¸º TokenIDï¼Œopenbrush åº“ä¼šæç¤º `Decoding` é”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨æ˜ å°„ `fid_list` å°† TokenID æ˜ å°„åˆ° fidã€‚åŒæ ·ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªæ˜ å°„å…¶ä¸­åŒ…å«æ‰€æœ‰åœ¨ `sale_list` ä¸Šå‡ºå”®çš„ NFTã€‚`collection_id` æ˜¯æˆ‘ä»¬ NFT é›†åˆçš„ä¸€ä¸ª IDï¼Œ`max_supply` æ˜¯æˆ‘ä»¬å¯ä»¥åœ¨æ™ºèƒ½åˆçº¦ä¸­é“¸é€ çš„ NFT çš„æœ€å¤§æ•°é‡ã€‚æœ€åï¼Œ`price_per_mint` æ˜¯æ¯ä¸ª NFT ä»£å¸çš„é“¸é€ ä»·æ ¼ã€‚é‡‘é¢ä» `price_per_mint` ä¸­è·å¾—å¹¶æ”¶é›†åœ¨æ™ºèƒ½åˆçº¦ä¸­ï¼Œå¯ç”±åˆçº¦æ‰€æœ‰è€…æå–ã€‚

# å°†é’±åŒ…æ·»åŠ åˆ°æ‚¨çš„åº”ç”¨ç¨‹åº

æˆ‘ä»¬çš„åº”ç”¨ç¨‹åºéœ€è¦ä¸€ä¸ªé’±åŒ…æ¥å¸®åŠ©æˆ‘ä»¬ç­¾ç½²ä¸å­˜å‚¨å’Œ NFT ç›¸å…³çš„äº¤æ˜“å¹¶åœ¨ CESS ç½‘ç»œä¸Šå¹¿æ’­ã€‚ç”±äº CESS æ„å»ºåœ¨ Substrate æ¡†æ¶ä¹‹ä¸Šï¼Œå› æ­¤ CESS æ”¯æŒ [polkadot.js](https://polkadot.js.org/) é’±åŒ…ã€‚æ ¹æ®æ‚¨é€‰æ‹©çš„å‰ç«¯å †æ ˆï¼ŒPolkadot æä¾›å¯¹å¤šä¸ªå¹³å°çš„æ”¯æŒï¼Œä¾‹å¦‚ï¼š

- å¯¹äº Web åº”ç”¨ç¨‹åºï¼Œè¯·éµå¾ª [Polkadot.js Extension](https://polkadot.js.org/docs/extension/)
- å¯¹äº Android åº”ç”¨ç¨‹åºï¼Œè¯·éµå¾ª [Nova Substrate SDK for Android](https://github.com/novasamatech/substrate-sdk-android)
- å¯¹äº iOS åº”ç”¨ç¨‹åºï¼Œè¯·éµå¾ª [Nova Substrate SDK for iOS](https://github.com/novasamatech/substrate-sdk-ios)

é’±åŒ…ä¸åº”ç”¨ç¨‹åºé›†æˆåï¼Œè¯·ç¡®ä¿å°†å…¶é…ç½®åˆ° CESS æµ‹è¯•ç½‘ç»œã€‚

# å°†èµ„äº§ä¸Šä¼ è‡³ CESS

CESS ä¸ºæˆ‘ä»¬æä¾›äº†å„ç§ SDK å’Œ RESTful API æ¥ä¸Šä¼ æˆ‘ä»¬çš„æ–‡ä»¶ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ CESS æµ‹è¯•ç½‘æ¥åˆ›å»ºæˆ‘ä»¬çš„ NFT äº¤æ˜“å¸‚åœºã€‚å’Œåœ¨ä¸»ç½‘ä¸Šåˆ›å»ºçš„æ­¥éª¤ç±»ä¼¼ã€‚æˆ‘ä»¬å°†æŠŠ CryptoPunk å›¾åƒä½œä¸ºæˆ‘ä»¬çš„èµ„äº§ä¸Šä¼ åˆ° CESSã€‚ä½†åœ¨å°†æ–‡ä»¶ä¸Šä¼ åˆ° CESS ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦æ»¡è¶³ä¸€äº›å‡†å¤‡æ¡ä»¶å¦‚ä¸ºå¸æˆ·æ³¨èµ„å’Œè´­ä¹°ç©ºé—´ã€‚

![Crypto Punk](../../assets/developer/tutorials/nft-marketplace/crypto-punk.png)

## ä¸ºæ‚¨çš„è´¦æˆ·æ³¨èµ„

ä¸ºæ‚¨çš„å¸æˆ·æ³¨èµ„ç›¸å½“å®¹æ˜“ã€‚è®¿é—® [CESS Testnet Faucet](https://testnet-faucet.cess.cloud/) å¹¶è¾“å…¥æ‚¨çš„å¸æˆ·åœ°å€ï¼Œç„¶åæŒ‰è·å– TCESSã€‚æ‚¨çš„è´¦æˆ·å°†è·å¾— 10,000 ä¸ª CESS ä»£å¸ã€‚

![CESS æµ‹è¯•ç½‘æ°´é¾™å¤´](../../assets/developer/tutorials/nft-marketplace/testnet-faucet.png)

## è´­ä¹°ç©ºé—´

è´­ä¹°ç©ºé—´æœ‰ä¸¤ç§é€‰æ‹©ã€‚

1. ä½¿ç”¨ SDK
2. [CESS Explorer](https://testnet.cess.cloud/)

### A. ä½¿ç”¨ SDK è´­ä¹°ç©ºé—´

æ ¹æ®æ‚¨ä¸ºåº”ç”¨ç¨‹åºé€‰æ‹©çš„ SDKï¼Œä»¥ä¸‹æ­¥éª¤ä¼šæœ‰ç›¸ä¼¼ä¹‹å¤„ã€‚æˆ‘ä»¬å°†åœ¨æœ¬æŒ‡å—ä¸­ä½¿ç”¨ [Javascript SDK](https://github.com/CESSProject/cess-js-sdk)ã€‚

1. å®‰è£… JavaScript SDK

    ```bash
    # npm
    npm i cess-js-sdk --save
    # yarn
    yarn add cess-js-sdk -S
    # pnpm
    pnpm add cess-js-sdk
    ```

2. å¯¼å…¥ SDK

    ```js
    import { InitAPI, Space } from "cess-js-sdk";
    ```

3. åˆå§‹åŒ– API

    ```js
    const {api, keyring} = InitAPI();
    const space = new Space(api, keyring);
    ```

4. å‡ºç§Ÿç©ºé—´

    ```js
    // Rent 1GB of storage space for 30 days.
    result = await space.buySpace(mnemonic, 1);
    ```

### B. ä½¿ç”¨ CESS Explorer è´­ä¹°ç©ºé—´

è¦è´­ä¹°ç©ºé—´ï¼Œé¦–å…ˆï¼Œå¯¼èˆªåˆ° [CESS Explorer](https://testnet.cess.cloud/) å¹¶æŒ‰ç…§è¯´æ˜è¿›è¡Œæ“ä½œã€‚

1. å¯¼èˆªåˆ° Developer > Extrinsics

    ![å‘é€äº¤æ˜“](../../assets/developer/tutorials/nft-marketplace/01-extrinsics.png)

2. é€‰æ‹©é€‚å½“çš„å¸æˆ·ã€‚ç„¶åé€‰æ‹©åœ¨ â€œsubmit the following extrinsicâ€ ä¸­é€‰æ‹© `storageHandler`ï¼Œç„¶åé€‰æ‹©`buySpace(gibCount)`ã€‚è¾“å…¥æ‚¨æƒ³è¦è´­ä¹°çš„å­˜å‚¨ç©ºé—´é‡ï¼Œç„¶åå•å‡»æäº¤äº¤æ˜“ã€‚

    ![ç§Ÿèµç©ºé—´](../../assets/developer/tutorials/nft-marketplace/02-purchase-space.png)

## ä¸Šä¼ æ–‡ä»¶è‡³ CESS

ä¸€æ—¦æˆ‘ä»¬çš„å¸æˆ·ä¸­æœ‰ä»£å¸å¹¶ä¸”ä¸ºæˆ‘ä»¬çš„å¸æˆ·åˆ†é…äº†è¶³å¤Ÿçš„å­˜å‚¨ç©ºé—´ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†æ–‡ä»¶ä¸Šä¼ åˆ° CESS ç½‘ç»œã€‚ç”±äºæˆ‘ä»¬å°†ä½¿ç”¨ CESS DeOSS ç½‘å…³ä¸Šä¼ æ–‡ä»¶ï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»å¯¹ DeOSS ç½‘å…³è¿›è¡Œèº«ä»½éªŒè¯ï¼Œä»¥ä¾¿ç½‘å…³å¯ä»¥ä»£è¡¨æˆ‘ä»¬å‘é€ä¸€äº›ä¸å­˜å‚¨ç›¸å…³çš„äº¤æ˜“å¹¶ç”Ÿæˆæˆæƒä»¤ç‰Œã€‚å¯¹äºæµ‹è¯•ç½‘ DeOSSï¼Œè¯·äº†è§£ä»¥ä¸‹ä¿¡æ¯ï¼š

{% hint style="info" %}
ğŸ’¡ DeOSS ç½‘å€ï¼š<http://deoss-pub-gateway.cess.cloud/>

DeOSS ç½‘å…³è´¦æˆ·åœ°å€ï¼š`cXhwBytXqrZLr1qM5NHJhCzEMckSTzNKw17ci2aHft6ETSQm9`
{% endhint %}

1. æ‰§è¡Œ `oss` > `authorize(operator)` ä»¥ä»æµ‹è¯•ç½‘ explorer å¤–éƒ¨éªŒè¯ DeOSSï¼Œè¯·ä½¿ç”¨ä¸Šé¢ç»™å‡ºçš„ç½‘å…³å¸æˆ·åœ°å€ã€‚

    ![å‘é€ `authorize` äº¤æ˜“](../../assets/developer/tutorials/nft-marketplace/authorize.png)

2. ç”Ÿæˆæˆæƒä»¤ç‰Œï¼šå¦‚éœ€ç”Ÿæˆæˆæƒä»¤ç‰Œï¼Œè¯·éµå¾ªæœ¬æŒ‡å—ã€‚å¤§çº¦éœ€è¦ 5 åˆ†é’Ÿã€‚

ç°åœ¨æˆ‘ä»¬å‡†å¤‡å°†æ–‡ä»¶ä¸Šä¼ åˆ° CESSã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ REST API æˆ– SDK æ¥ä¸Šä¼ æ–‡ä»¶ã€‚

### A. ä½¿ç”¨ SDK ä¸Šä¼ 

æˆ‘ä»¬å°†å†æ¬¡ä½¿ç”¨ Javascript SDK ä¸Šä¼ æ–‡ä»¶ã€‚åˆå§‹åŒ–é˜¶æ®µä¸ä¸Šä¸€èŠ‚ç›¸åŒã€‚åˆå§‹åŒ–åï¼Œæˆ‘ä»¬å¯ä»¥æ·»åŠ ä»¥ä¸‹ä»£ç ç‰‡æ®µã€‚

```js
import { InitAPI, Space, File } from "cess-js-sdk";
const MNEMONIC = "YOUR MNEMONIC SEED";
const ACCOUNT_ID = "YOUR ACCOUNT ID";
const FILE_PATH = resolvePath(joinPath(__dirname, "/home/image.png"));
let BUCKET_NAME = "bucket1";

async function main() {
  const { api, keyring } = await InitAPI(testnetConfig);
  const oss = new File(api, keyring, gatewayURL, true);
  const result = await oss.uploadFile(MNEMONIC, ACCOUNT_ID, FILE_PATH, BUCKET_NAME);
  console.log(getDataIfOk(result), "\n");
}
```

### B. ä½¿ç”¨ REST API ä¸Šä¼ 

ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ REST API å°†æ–‡ä»¶ä¸Šä¼ åˆ° CESS ç½‘ç»œã€‚

è¦ä¸Šä¼ æ–‡ä»¶ï¼Œè¯·æ‰§è¡Œä»¥ä¸‹å‘½ä»¤

```bash
curl -X PUT http://deoss-pub-gateway.cess.cloud/ \
  -F 'file=@cryptopunk.png;type=image/png' \
  -H "Authorization: eyJh...IL1g" \
  -H "BucketName: my_nfts"
```

æ­¤å¤„ï¼Œ`-F` ç”¨äºæŒ‡å®šæ–‡ä»¶ä½ç½®å’Œæ–‡ä»¶ç±»å‹ï¼Œ`-H` è®¾ç½®æ‚¨çš„ `Authorization` ä»¤ç‰Œä»¥åŠ `BucketName` è¯¥æ–‡ä»¶çš„å­˜å‚¨ä½ç½®ã€‚

æ‰§è¡Œæ­¤å‡½æ•°å°†è¿”å›ä¸€ä¸ª FIDï¼Œæˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥è®¿é—®æˆ‘ä»¬çš„æ–‡ä»¶ã€‚

# NFT äº¤æ˜“å¸‚åœºæ™ºèƒ½åˆçº¦

![ink!](../../assets/developer/tutorials/nft-marketplace/use-ink.png)

æˆ‘ä»¬å°†ä½¿ç”¨ [ink!](https://use.ink/) è¯­è¨€ç¼–å†™æ™ºèƒ½åˆçº¦ã€‚æ­£å¦‚ä¸Šé¢æåˆ°çš„ï¼Œæˆ‘ä»¬çš„æ™ºèƒ½åˆçº¦å°†ç”¨äºåˆ›å»ºåŸºäº [PSP34](https://github.com/w3f/PSPs/blob/master/PSPs/psp-34.md) æ ‡å‡†çš„ NFTã€‚åœ¨æˆ‘ä»¬å¼€å§‹ä¹‹å‰ï¼Œæœ‰ä¸€äº›å…ˆå†³æ¡ä»¶ã€‚è¯·æŸ¥çœ‹ [Deploy an ink! Smart Contract](https://docs.cess.cloud/core/developer/tutorials/deploy-sc-ink) æ•™ç¨‹å¹¶å®‰è£… Rust å’Œ`cargo-contract`.

## å¼€å‘

1. è®©æˆ‘ä»¬ä»åˆ›å»ºä¸€ä¸ªæ–°åˆçº¦å¼€å§‹

    ```bash
    cargo contract new nft_market
    cd nft_market
    ```

    æœ€åä¸€ä¸ªå‘½ä»¤å°†åˆ›å»º ink! åˆçº¦é¡¹ç›®çš„æ¡†æ¶ã€‚

    è¯¥ç›®å½•å†…æœ‰ä¸‰ä¸ªæ–‡ä»¶ã€‚

    ```
    nft_market/
      âˆŸ .gitignore    # contains files to ignore when committing to git
      âˆŸ Cargo.toml    # This is a Rust project, so there is a Cargo.toml file for the project specification.
      âˆŸ lib.rs        # The actual smart contract and unit test code.
    ```

2. è®©æˆ‘ä»¬æ„å»ºå¹¶æµ‹è¯•åˆçº¦

    ```bash
    cargo contract build # This command builds the contract project.
    cargo test           # This command runs the unit test code starting at the `mod tests` line in the code.
    ```

    è¿è¡Œ `cargo contract build` ç”Ÿæˆä¸‰ä¸ªæ–‡ä»¶ï¼š

    - `contract.wasm`: åˆçº¦ä»£ç 
    - `contract.json`ï¼šåˆçº¦å…ƒæ•°æ®
    - `contract.contract`ï¼šåˆçº¦ä»£ç å’Œå…ƒæ•°æ®

    å‰ç«¯ï¼ˆå‚è§ä¸‹ä¸€èŠ‚ï¼‰éœ€è¦é˜…è¯» `contract.json` åˆçº¦çš„ APIã€‚æˆ‘ä»¬å°†ç”¨äº `contract.contract` åœ¨é“¾ä¸Šå®ä¾‹åŒ–åˆçº¦ã€‚


3. æˆ‘ä»¬å°†ä½¿ç”¨åŸºäº PSP34 Token æ ‡å‡†çš„ [openbrush åº“](https://github.com/Brushfam/openbrush-contracts) ä»¥åŠè®¸å¤šå…¶ä»–ç¼–å†™ ink! çš„æœ‰ç”¨åŠŸèƒ½ï¼Œä½¿æˆ‘ä»¬çš„å¼€å‘æ›´å¿«ã€æ›´å®‰å…¨ã€æ›´è½»æ¾ã€‚è¦å°† openbrush åº“æ·»åŠ åˆ°æ‚¨çš„é¡¹ç›®ä¸­ï¼Œè¯·åœ¨æ‚¨çš„ `Cargo.toml` åŠ ä»¥ä¸‹çš„ä¾èµ–ã€‚å¦å¤–ï¼Œå°†æ‚¨çš„ `ink` ä¾èµ–é¡¹ä» `4.2.0` æ›´æ–°ä¸º `~4.2.1`ã€‚

    ```toml
    [dependencies]
    ink = { version = "~4.2.1", default-features = false }
    #...
    openbrush = { tag = "4.0.0-beta", git = "https://github.com/Brushfam/openbrush-contracts", default-features = false, features = ["psp34", "ownable", "reentrancy_guard"] }
    #...
    ```

    ç°åœ¨ï¼Œæ·»åŠ `openbrush/std`åˆ°`[features]`ï¼š

    ```toml
    [features]
    default = ["std"]
    std = [
        # ...,
        "openbrush/std",
    ]
    ```

4. æ‰“å¼€`lib.rs`å¹¶åˆ é™¤é™¤é¡¶å±‚ç»“æ„ä¹‹å¤–çš„æ‰€æœ‰å†…å®¹ï¼Œå¦‚ä¸‹ï¼š

    ```rust
    #![cfg_attr(not(feature = "std"), no_std, no_main)]

    #[ink::contract]
    mod nft_market {
      // We will fill up the code here next
    }
    ```

5. è®©æˆ‘ä»¬å…ˆä» Openbrush æ·»åŠ æ‰€éœ€çš„ç»„ä»¶å¼€å§‹ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ PSP34 ä»£å¸æ ‡å‡†ï¼Œ`Ownable`ç”¨äºå¯ä»¥æ‹¥æœ‰çš„ä»£å¸ï¼Œ`PSP34Mintable` ä½¿ç”¨æˆ·èƒ½å¤Ÿé“¸é€ æ–°ä»£å¸ï¼Œ`PSP34Metadata`å°†æˆ‘ä»¬çš„å…ƒæ•°æ®å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šï¼Œ`PSP34Enumerable` è¿›è¡Œæšä¸¾ã€‚æˆ‘ä»¬è¿˜éœ€è¦æ›´æ”¹ `ink::contract` ä¸º `openbrush::contract`ã€‚

    ```rust
    #![cfg_attr(not(feature = "std"), no_std, no_main)]

    mod impls;

    #[openbrush::implementation(PSP34, PSP34Mintable, PSP34Metadata, PSP34Enumerable, Ownable)]
    #[openbrush::contract]
    mod nft_market {
      // We will fill up the code here next
    }
    ```

6. ink! åˆçº¦éœ€è¦ä¸€ä¸ª `struct` æ¥å°†æˆ‘ä»¬çš„æ•°æ®å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šï¼Œæœ€å°‘éœ€è¦ä¸€ä¸ªæ„é€ å‡½æ•°å’Œä¸€ä¸ªæ¶ˆæ¯å‡½æ•°ã€‚è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬é¦–å…ˆåœ¨ `struct` å­˜å‚¨ä¸­æ·»åŠ åœ¨ `nft_market` æ¨¡å—å†…ã€‚

    ```rust
    //...
    mod nft_market {
        // We will add our dependencies here
        #[ink(storage)]
        #[derive(Default, Storage)]
        pub struct NftMarket {
            #[storage_field]
            psp34: psp34::Data,
            #[storage_field]
            guard: reentrancy_guard::Data,
            #[storage_field]
            ownable: ownable::Data,
            #[storage_field]
            metadata: metadata::Data,
            #[storage_field]
            nftdata: impls::types::NftData,
            #[storage_field]
            enumerable: enumerable::Data,
        }
    }
    ```

    æˆ‘ä»¬å¸Œæœ›å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šçš„æ¯ç§æ•°æ®ç±»å‹éƒ½éœ€è¦ç”¨ `#[storage_field]` å®æ¥æŒ‡å®šã€‚

    - `psp34`ï¼šå­˜å‚¨ PSP34 ä»¤ç‰Œæ ‡å‡†ç›¸å…³æ•°æ®
    - `guard`ï¼šç”¨äºé˜²æ­¢é‡å…¥æ”»å‡»
    - `ownable`ï¼šå…è®¸æˆ‘ä»¬åˆ›å»ºä¹Ÿå¯ä»¥ä¼ è¾“çš„å¯æ‹¥æœ‰æ•°æ®ï¼Œ
    - `metadata`ï¼šå­˜å‚¨è‡ªå®šä¹‰å±æ€§
    - `nftdata`ï¼šæˆ‘ä»¬å°†åœ¨è¿™é‡Œå­˜å‚¨ NFT ç›¸å…³æ•°æ®ï¼Œä¾‹å¦‚æœ€å¤§ä¾›åº”é‡ã€æ¯æšé“¸å¸çš„ä»·æ ¼ç­‰ã€‚
    - `enumerable`ï¼šæŸ¥è¯¢ NFT å‘è¡Œæ•°é‡æˆ–æŸ¥è¯¢ NFT ä»£å¸ã€‚

7. ç°åœ¨æˆ‘ä»¬éœ€è¦å®ç° NftMarket ç»“æ„å¹¶å‘å…¶æ·»åŠ æ„é€ å‡½æ•°ã€‚

    ```rust
    //...
    mod nft_market {
        ...
        pub struct NftMarket {
           ...
        }

        impl NftMarket {
        #[ink(constructor)]
            pub fn new() -> Self {
                // We will add our code here
            }
        }
    }
    ```

8. ç”±äºç°åœ¨å·²ç»æœ‰äº†æ„é€ å‡½æ•°ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨ â€œWe will add our dependencies hereâ€ éƒ¨åˆ†æ·»åŠ ä¾èµ–é¡¹ã€‚

    ```rust
    //...
    mod nft_market {
        use crate::impls;
        use ink::codegen::{EmitEvent, Env};
        use openbrush::{
            contracts::{
                psp34::{extensions::metadata, PSP34Impl},
                reentrancy_guard,
            },
            traits::Storage,
        };
        //...
    }
    ```

    è¯·æ³¨æ„ï¼Œæˆ‘ä»¬å°šæœªåˆ›å»ºåœ¨æ­¤å¤„æ·»åŠ ä¸ºä¾èµ–é¡¹çš„ impls æ¨¡å—ã€‚ä½†æˆ‘ä»¬å¾ˆå¿«å°±ä¼šåˆ›å»ºå®ƒã€‚

9. ä¸ºäº†ä¿æŒæ™ºèƒ½åˆçº¦çš„çµæ´»æ€§ï¼Œæˆ‘ä»¬å°†åœ¨éƒ¨ç½²æ™ºèƒ½åˆçº¦æ—¶ä»ç”¨æˆ·é‚£é‡Œè·å–ä¸€äº›è¾“å…¥ï¼Œä½¿ä»–ä»¬èƒ½å¤Ÿè®¾ç½®

    1. `name`: æ™ºèƒ½åˆçº¦çš„åç§°
    2. `symbol`: ä»£å¸ç¬¦å·
    3. `base_uri`: åœ¨å“ªé‡Œè®¿é—®æˆ‘ä»¬çš„ NFT æ–‡ä»¶
    4. `price_per_mint`: ç”¨æˆ·é“¸é€ ä»£å¸æ‰€éœ€æ”¯ä»˜çš„ CESS ä»£å¸æ•°é‡

    ç°åœ¨æˆ‘ä»¬æ¥å®šä¹‰åœ¨æ­¥éª¤ 7 ä¸­ç¼–å†™çš„æ„é€ å‡½æ•°ä¸»ä½“ã€‚

    ```rust
    //...
    impl NftMarket {
        #[ink(constructor)]
        pub fn new(
            name: String,
            symbol: String,
            base_uri: String,
            max_supply: u64,
            price_per_mint: Balance,
        ) -> Self {
            let mut instance = Self::default();
            let caller = instance.env().caller();
            ownable::InternalImpl::_init_with_owner(&mut instance, caller);
            let col_id = PSP34Impl::collection_id(&instance);
            metadata::InternalImpl::_set_attribute(
                &mut instance,
                col_id.clone(),
                String::from("name"),
                name,
            );
            metadata::InternalImpl::_set_attribute(
                &mut instance,
                col_id.clone(),
                String::from("symbol"),
                symbol,
            );
            metadata::InternalImpl::_set_attribute(
                &mut instance,
                col_id,
                String::from("baseUri"),
                base_uri,
            );
            instance.nftdata.max_supply = max_supply;
            instance.nftdata.price_per_mint = price_per_mint;
            instance
        }
    }
    ```

10. äº‹ä»¶ï¼ˆEventsï¼‰ï¼šè¦åœ¨æ™ºèƒ½åˆçº¦ä¸­å‘ç”ŸæŸä¸ªäº‹ä»¶æ—¶å‘å‡ºäº‹ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `#[ink(event)]`æ¥å®šä¹‰äº‹ä»¶ã€‚æˆ‘ä»¬å°†æ·»åŠ  `Transfer` å’Œ `Approval` äº‹ä»¶ï¼Œè¦†ç›– `psp34::Internal` çš„äº‹ä»¶ã€‚

    ```rust
    mod nft_market {
    //...
        /// Event emitted when a token transfer occurs.
        #[ink(event)]
        pub struct Transfer {
            #[ink(topic)]
            from: Option<AccountId>,
            #[ink(topic)]
            to: Option<AccountId>,
            #[ink(topic)]
            id: Id,
        }

        /// Event emitted when a token approve occurs.
        #[ink(event)]
        pub struct Approval {
            #[ink(topic)]
            from: AccountId,
            #[ink(topic)]
            to: AccountId,
            #[ink(topic)]
            id: Option<Id>,
            approved: bool,
        }

        // Override event emission methods
        #[overrider(psp34::Internal)]
        fn _emit_transfer_event(&self, from: Option<AccountId>, to: Option<AccountId>, id: Id) {
            self.env().emit_event(Transfer { from, to, id });
        }

        #[overrider(psp34::Internal)]
        fn _emit_approval_event(&self, from: AccountId, to: AccountId, id: Option<Id>, approved: bool) {
            self.env().emit_event(Approval {
                from,
                to,
                id,
                approved,
            });
        }
    //...
    }
    ```

11. ç°åœ¨è®©æˆ‘ä»¬åˆ›å»ºè‡ªå®šä¹‰å­˜å‚¨é¡¹ç›® `NftData`ã€‚éœ€è¦ä¸ºæ­¤åˆ›å»ºä¸€ä¸ªæ–°ç›®å½• `impls` å¹¶åˆ›å»º `mod.rs`,`types.rs` å’Œ `market.rs`. æ‚¨çš„ç›®å½•ç»“æ„åº”å¦‚ä¸‹æ‰€ç¤ºï¼š

    ```
    .
    â”œâ”€â”€ Cargo.lock
    â”œâ”€â”€ Cargo.toml
    â”œâ”€â”€ impls
    â”‚   â”œâ”€â”€ market.rs
    â”‚   â”œâ”€â”€ mod.rs
    â”‚   â””â”€â”€ types.rs
    â””â”€â”€ lib.rs
    ```

12. æ‰“å¼€ mod.rs æ–‡ä»¶å¹¶æ·»åŠ ï¼š

    ```rust
    pub mod market;
    pub mod types;
    ```

13. ç°åœ¨ï¼Œæ‰“å¼€ `types.rs` ä»¥åˆ›å»ºæˆ‘ä»¬çš„è‡ªå®šä¹‰ `NftData` ç»“æ„ã€‚

    ```rust
    use openbrush::{traits::{Balance, String}, storage::Mapping, contracts::psp34::Id};

    #[derive(Default, Debug)]
    #[openbrush::storage_item]
    pub struct NftData {
        pub last_token_id: u64,
        pub collection_id: u32,
        pub max_supply: u64,
        pub price_per_mint: Balance,
        pub fid_list: Mapping<Id, String>,
        pub sale_list: Mapping<Id, Balance>,
    }
    ```

    åœ¨è¿™æ®µä»£ç ä¸­ï¼š

    - `last_token_id` ä¿å­˜æœ€æ–°é“¸é€ çš„ä»£å¸ IDã€‚è¿™æ ·ï¼Œç”Ÿæˆçš„æ¯ä¸ªæ–°ä»¤ç‰Œéƒ½ä¼šé€’å¢ï¼Œ`last_token_id` ä¸ºä»¤ç‰Œæä¾›å”¯ä¸€çš„ IDã€‚
    - `collection_id` æ˜¯æˆ‘ä»¬æ”¶è—çš„å”¯ä¸€ IDã€‚
    - `max_supply` æ˜¯æˆ‘ä»¬å¯ä»¥é“¸é€ çš„ NFT çš„æœ€å¤§æ•°é‡ã€‚
    - `price_per_mint` æ˜¯ç”¨æˆ·é“¸é€  NFT æ‰€éœ€æ”¯ä»˜çš„ä»·æ ¼ã€‚
    - `fid_list` æ˜¯æˆ‘ä»¬ä½œä¸º NFT é“¸é€ çš„ Token ID å’Œæ–‡ä»¶ ID çš„æ˜ å°„ã€‚
    - `sale_list` åŒ…å«åˆ—å‡ºå¾…å”®çš„ NFT åˆ—è¡¨ã€‚

    æˆ‘ä»¬åˆ›å»ºçš„ä»»ä½•éœ€è¦å­˜å‚¨åœ¨åŒºå—é“¾ä¸Šçš„è‡ªå®šä¹‰æ•°æ®ç»“æ„éƒ½éœ€è¦ç”¨ `#[openbrush::storage_item]` å®è¿›è¡Œæ ‡è®°ã€‚æˆ‘ä»¬è¿˜å°†æ·»åŠ ä¸€ä¸ª `enum` ç”¨æ¥åŒ…å«æ‰€æœ‰é”™è¯¯æ¶ˆæ¯çš„å†…å®¹ã€‚

    ```rust
    //...
    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub enum NftError {
        BadMintValue,
        CollectionIsFull,
        WithdrawalFailed,
        NotTokenOwner,
        NotForSale,
        OwnToken,
        PriceNotMatch,
        TransferNativeTokenFailed,
    }

    impl NftError {
        pub fn as_str(&self) -> String {
            match self {
                NftError::BadMintValue => String::from("BadMintValue"),
                NftError::CollectionIsFull => String::from("CollectionIsFull"),
                NftError::WithdrawalFailed => String::from("WithdrawalFailed"),
                NftError::NotTokenOwner => String::from("NotTokenOwner"),
                NftError::NotForSale => String::from("NotForSale"),
                NftError::OwnToken => String::from("OwnToken"),
                NftError::PriceNotMatch => String::from("PriceNotMatch"),
                NftError::TransferNativeTokenFailed => String::from("TransferNativeTokenFailed"),
            }
        }
    }
    ```

14. ç°åœ¨è¿›å…¥äº†ä»¤äººå…´å¥‹çš„éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ç¼–å†™å®é™…çš„åˆçº¦åŠŸèƒ½â€”â€”å°±åœ¨æˆ‘ä»¬çš„ `market.rs` æ–‡ä»¶é‡Œã€‚åœ¨æˆ‘ä»¬çš„ `market.rs` æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬å°†æ·»åŠ ç»§æ‰¿ openbrush ç‰¹å¾çš„è‡ªå®šä¹‰ç‰¹å¾ï¼Œä»¥å°†æˆ‘ä»¬é‡‡ç”¨çš„æ–¹å¼æ·»åŠ åˆ°åˆçº¦ä¸­ã€‚

    ```rust
    use ink::prelude::string::ToString;

    use openbrush::{
        contracts::{
            ownable::{self, only_owner},
            psp34::{
                self,
                extensions::metadata::{self, PSP34MetadataImpl},
                Id, PSP34Error, PSP34Impl,
            },
            reentrancy_guard,
            reentrancy_guard::non_reentrant,
        },
        modifiers,
        traits::{AccountId, Balance, Storage, String},
    };

    use super::types::{NftData, NftError};

    #[openbrush::trait_definition]
    pub trait MarketImpl:
        Storage<NftData>
        + Storage<psp34::Data>
        + Storage<reentrancy_guard::Data>
        + Storage<ownable::Data>
        + Storage<metadata::Data>
        + PSP34Impl
        + PSP34MetadataImpl
        + psp34::extensions::metadata::Internal
        + Internal
    {
        // We will write our functions here
    }
    ```

15. è®©æˆ‘ä»¬å°†ç¬¬ä¸€ä¸ªå‡½æ•° `mint` å‡½æ•°ï¼Œæ·»åŠ åˆ° `MarketImpl` ä¸­ã€‚è¿™å°†ç”¨æ¥é“¸é€ æˆ‘ä»¬çš„ NFTã€‚

    ```rust
    // Mint token to
    #[ink(message, payable)]
    #[modifiers(non_reentrant)]
    fn mint(&mut self, fid: String) -> Result<Id, PSP34Error> {
        self.check_fid(fid.clone())?;
        self.check_value(Self::env().transferred_value())?;

        let caller = Self::env().caller();
        let id = Id::U64(self.data::<NftData>().last_token_id + 1); // first mint id is 1
        self._mint_to(caller, id.clone())?;
        self.data::<NftData>().fid_list.insert(&id, &fid);
        self.data::<NftData>().last_token_id += 1;
        Ok(id)
    }
    ```

    ç”±äºç”¨æˆ·å¿…é¡»æ”¯ä»˜ä»£å¸æ‰èƒ½é“¸é€  NFTï¼Œå› æ­¤æˆ‘ä»¬å°†ä¸ºæ­¤å‡½æ•°æ·»åŠ  `payable` å®ã€‚æ­¤å¤–ï¼Œæ·»åŠ  `message` å®ä½¿ API å¯ä»¥ä½¿ç”¨è¯¥å‡½æ•°æ¥è°ƒç”¨åˆçº¦ã€‚æ›´å¤šå…³äº `message` çš„ä¿¡æ¯å¯ä»¥ç‚¹å‡» [æ­¤å¤„](https://use.ink/macros-attributes/message) æ‰¾åˆ°ã€‚

    è‡³äº check_fid å’Œ check_value å‡½æ•°ï¼Œæˆ‘ä»¬å°†åœ¨åé¢çš„éƒ¨åˆ†ä¸­å®šä¹‰å®ƒä»¬ã€‚`mint` å‡½æ•°æ¥å— `fid` ä½œä¸ºç”¨æˆ·çš„è¾“å…¥ã€‚`fid` æ˜¯æˆ‘ä»¬å°†æ–‡ä»¶ä¸Šä¼ åˆ° CESS ç½‘ç»œæ—¶è·å¾—çš„æ–‡ä»¶ IDã€‚åœ¨æˆ‘ä»¬çš„ `mint` å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆé€šè¿‡è°ƒç”¨ `Self::env()::caller()` æå– `caller` ï¼Œç„¶åç”Ÿæˆä¸€ä¸ªæ–°çš„ä»£å¸ `id`ï¼Œå¹¶å°† NFT ä»£å¸é“¸é€ ç»™è°ƒç”¨è€…ã€‚æˆ‘ä»¬è¿˜å°†æ–‡ä»¶ ID å­˜å‚¨åœ¨ `fid_list` æ˜ å°„ä¸­ï¼Œè¯¥æ˜ å°„å°†æŠŠ Token çš„ `id` æ˜ å°„ä¸º `fid`ã€‚æœ€åï¼Œæˆ‘ä»¬å¢åŠ  `last_token_id`ã€‚

16. å¦‚æœæ‚¨æƒ³è®©ç”¨æˆ·ä¸ºå…¶ä»–ç”¨æˆ·é“¸é€ ä»£å¸ï¼Œæ‚¨å¯ä»¥æ·»åŠ ä»¥ä¸‹åŠŸèƒ½ã€‚

    ```rust
    // Mint token to
    #[ink(message, payable)]
    #[modifiers(non_reentrant)]
    fn mint_to(&mut self, to: AccountId, fid: String) -> Result<Id, PSP34Error> {
        self.check_fid(fid.clone())?;
        self.check_value(Self::env().transferred_value())?;

        let id = Id::U64(self.data::<NftData>().last_token_id + 1); // first mint id is 1
        self._mint_to(to, id.clone())?;
        self.data::<NftData>().fid_list.insert(&id, &fid);
        self.data::<NftData>().last_token_id += 1;
        Ok(id)
    }
    ```

17. ä½¿åˆçº¦æ‰€æœ‰è€…èƒ½å¤Ÿè®¾ç½®æˆ–æ›´æ–° `base_uri` å¹¶ `max_supply`ï¼Œè¯·æ·»åŠ ä»¥ä¸‹åŠŸèƒ½ï¼š

    ```rust
    // Set new value for the baseUri
    #[ink(message)]
    #[modifiers(only_owner)]
    fn set_base_uri(&mut self, uri: String) -> Result<(), PSP34Error> {
        let id = PSP34Impl::collection_id(self);
        metadata::Internal::_set_attribute(self, id, String::from("baseUri"), uri);
        Ok(())
    }

    // Set max supply of tokens
    #[ink(message)]
    #[modifiers(only_owner)]
    fn set_max_supply(&mut self, value: u64) -> Result<(), PSP34Error> {
        self.data::<NftData>().max_supply = value;
        Ok(())
    }
    ```
    > æ³¨æ„ï¼š`#[modifiers(only_owner)]` å‡½æ•°é¡¾åæ€ä¹‰ï¼Œåªèƒ½ç”±åˆçº¦æ‰€æœ‰è€…è°ƒç”¨ã€‚

18. è®©æˆ‘ä»¬æ·»åŠ ä¸€äº›å‡½æ•°ï¼Œç”¨æˆ·å¯ä»¥è°ƒç”¨è¿™äº›å‡½æ•°æ¥è·å–å­˜å‚¨åœ¨åˆçº¦ä¸­çš„ä¸€äº›ä¿¡æ¯ã€‚

    ```rust
    // Get URI from token ID
    #[ink(message)]
    fn token_uri(&self, id: u64) -> Result<String, PSP34Error> {
        let id = Id::U64(id);
        self.token_exists(id.clone())?;
        let base_uri = PSP34MetadataImpl::get_attribute(
            self,
            PSP34Impl::collection_id(self),
            String::from("baseUri"),
        );
        let fid = self
            .data::<NftData>()
            .fid_list
            .get(&id)
            .ok_or(PSP34Error::TokenNotExists)?;

        let token_uri = base_uri.unwrap() + &fid;
        Ok(token_uri)
    }

    // Get token price
    #[ink(message)]
    fn price(&self, id: u64) -> Result<Balance, PSP34Error> {
        let id = Id::U64(id);
        let price = self
            .data::<NftData>()
            .sale_list
            .get(&id)
            .ok_or(PSP34Error::Custom(NftError::NotForSale.as_str()));
        price
    }

    // Get price per mint
    #[ink(message)]
    fn price_per_mint(&self) -> Balance {
        self.data::<NftData>().price_per_mint
    }

    // Get max supply of tokens
    #[ink(message)]
    fn max_supply(&self) -> u64 {
        self.data::<NftData>().max_supply
    }

     // Get Contract Balance
    #[ink(message)]
    fn balance(&mut self) -> Balance {
        let balance = Self::env().balance();
        let current_balance = balance
            .checked_sub(Self::env().minimum_balance())
            .unwrap_or_default();
        current_balance
    }
    ```

19. æœ€åè®©æˆ‘ä»¬æ·»åŠ å…è®¸ç”¨æˆ·å±•ç¤ºå’Œå‡ºå”® NFT çš„åŠŸèƒ½ã€‚

    ```rust
    /// Lists NFT for Sale
    #[ink(message)]
    fn list(&mut self, id: u64, price: Balance) -> Result<(), PSP34Error> {
        let id = Id::U64(id);
        self.check_owner(id.clone())?;
        self.data::<NftData>()
            .sale_list
            .insert(&id, &(price * 1_000_000_000_000));
        Ok(())
    }

    /// Delist NFT from Sale
    #[ink(message)]
    fn delist(&mut self, id: u64) -> Result<(), PSP34Error> {
        let id = Id::U64(id);
        self.check_owner(id.clone())?;
        if self.data::<NftData>().sale_list.get(&id).is_none() {
            return Err(PSP34Error::Custom(NftError::NotForSale.as_str()));
        }
        self.data::<NftData>().sale_list.remove(&id);
        Ok(())
    }

    /// Purchase NFT that is listed for Sale
    #[ink(message, payable)]
    fn purchase(&mut self, id: u64) -> Result<(), PSP34Error> {
        let id = Id::U64(id);
        let owner = self._check_token_exists(&id.clone())?;
        let caller = Self::env().caller();
        if owner == caller {
            return Err(PSP34Error::Custom(NftError::OwnToken.as_str()));
        };

        let price = self
            .data::<NftData>()
            .sale_list
            .get(&id)
            .ok_or(PSP34Error::Custom(NftError::NotForSale.as_str()))?;
        let transferred = Self::env().transferred_value();

        if price != transferred {
            return Err(PSP34Error::Custom(
                NftError::PriceNotMatch.as_str()
                    + "Required:"
                    + &price.to_string()
                    + ", Supplied:"
                    + &transferred.to_string(),
            ));
        }

        // Transfer native tokes
        if Self::env().transfer(owner, price).is_err() {
            return Err(PSP34Error::Custom(
                NftError::TransferNativeTokenFailed.as_str(),
            ));
        }

        self.data::<NftData>().sale_list.remove(&id);

        // Transfer NFT Token
        self._before_token_transfer(Some(&owner), Some(&caller), &id)?;
        self._remove_operator_approvals(&owner, &caller, &Some(&id));
        self._remove_token_owner(&id);
        self._insert_token_owner(&id, &caller);
        self._after_token_transfer(Some(&owner), Some(&caller), &id)?;
        self._emit_transfer_event(Some(owner), Some(caller), id.clone());

        // TODO: Move CESS File metadata from owner to caller

        Ok(())
    }

    /// Withdraws funds to contract owner
    #[ink(message)]
    #[modifiers(only_owner)]
    fn withdraw(&mut self) -> Result<(), PSP34Error> {
        let balance = Self::env().balance();
        let current_balance = balance
            .checked_sub(Self::env().minimum_balance())
            .unwrap_or_default();
        let owner = self.data::<ownable::Data>().owner.get().unwrap().unwrap();
        Self::env()
            .transfer(owner, current_balance)
            .map_err(|_| PSP34Error::Custom(NftError::WithdrawalFailed.as_str()))?;
        Ok(())
    }
    ```

    è¯¥ `list` å‡½æ•°è®²åˆ—å‡ºæ‰€æœ‰å¾…å”®çš„ NFTï¼ŒåŒæ—¶ `delist` å°†æˆ‘ä»¬çš„ NFT ä¸‹æ¶ã€‚ä¸€æ—¦ç”¨æˆ·å°†å…¶ NFT æŒ‚ç‰Œå‡ºå”®ï¼Œè¯¥ NFT å°±å¯ä¾›å…¶ä»–ç”¨æˆ·è´­ä¹°ã€‚ä»–ä»¬å¯ä»¥è°ƒç”¨ `purchase` å‡½æ•°å¾—åˆ°æƒ³è¦è´­ä¹°çš„ NFT çš„ NFT ID ã€‚ç”±äºè´­ä¹°æ˜¯ä»˜è´¹åŠŸèƒ½ï¼Œç”¨æˆ·è¿˜å¿…é¡»è½¬ç§»æ‰€éœ€æ•°é‡çš„ä»£å¸æ‰èƒ½æˆåŠŸè½¬ç§»ã€‚


    > ğŸ’¡ æ¸©é¦¨æç¤ºï¼šåœ¨ `market.rs` æ–‡ä»¶ä¸­æ‚¨ä¼šæ³¨æ„åˆ°ä¸€äº›å¾…åŠã€‚ä¸ºäº†ä½¿æ•™ç¨‹ç®€å•ï¼Œæˆ‘ä»¬æ²¡æœ‰å®ç°è¿™äº›åŠŸèƒ½ã€‚

    æœ€åï¼Œè¯¥ `withdraw` å‡½æ•°æå–æ‰€æœ‰æ”¶é›†åˆ°çš„ä»£å¸ï¼ŒåŒæ—¶å°† NFT é“¸é€ åˆ°åˆçº¦æ‰€æœ‰è€…çš„åœ°å€ã€‚

20. ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä¸º NftData åˆ›å»ºä¸€ä¸ªç»§æ‰¿ `internal` ç‰¹å¾çš„è‡ªå®šä¹‰ç‰¹å¾ã€‚åœ¨è¿™ç‰¹å¾ä¸­å®šä¹‰çš„åŠŸèƒ½ä¸ä¼šæš´éœ²ç»™ç”¨æˆ·ï¼Œå› æ­¤ç§°ä¸ºå†…éƒ¨åŠŸèƒ½ (internal trait)ã€‚æˆ‘ä»¬å°†æ·»åŠ ä¸€äº›ç”¨äºéªŒè¯æ‰€æœ‰è€…ã€è½¬è´¦èµ„é‡‘ç­‰çš„åŠŸèƒ½ã€‚

    ```rust
    pub trait Internal: Storage<NftData> + psp34::Internal {
        /// Check if the caller is owner of the token
        fn check_owner(&self, id: Id) -> Result<(), PSP34Error> {
            let owner = self._check_token_exists(&id.clone())?;
            let caller = Self::env().caller();
            if owner != caller {
                return Err(PSP34Error::Custom(NftError::NotTokenOwner.as_str()));
            }
            Ok(())
        }

        /// Check if the transferred mint value is as expected
        fn check_value(&self, transferred_value: u128) -> Result<(), PSP34Error> {
            if transferred_value != self.data::<NftData>().price_per_mint {
                return Err(PSP34Error::Custom(
                    NftError::BadMintValue.as_str()
                        + "Required:"
                        + &self.data::<NftData>().price_per_mint.to_string()
                        + ", Supplied:"
                        + &transferred_value.to_string(),
                ));
            }

            if self.data::<NftData>().last_token_id >= self.data::<NftData>().max_supply {
                return Err(PSP34Error::Custom(NftError::CollectionIsFull.as_str()))
            }

            Ok(())
        }

        fn check_fid(&self, _fid: String) -> Result<(), PSP34Error> {
            // TODO: Check if fid exists in CESS Chain.
            Ok(())
        }

        fn token_exists(&self, id: Id) -> Result<(), PSP34Error> {
            self._owner_of(&id).ok_or(PSP34Error::TokenNotExists)?;
            Ok(())
        }
    }
    ```

21. æœ€åï¼Œè®©æˆ‘ä»¬ä¸º NftMarket æ·»åŠ ç‰¹å¾å®ç°ã€‚æ‰“å¼€ lib.rs å¹¶æ·»åŠ ä»¥ä¸‹ä»£ç ã€‚

    ```rust
    impl impls::market::Internal for NftMarket {}
    impl impls::market::MarketImpl for NftMarket {}

    impl NftMarket {
      //...
    }
    ```

    è‡³æ­¤ï¼Œæˆ‘ä»¬çš„æ™ºèƒ½åˆçº¦ç°åœ¨å°±å¯ä»¥ç¼–è¯‘å’Œéƒ¨ç½²äº†ã€‚è¯·éµå¾ª ink! åˆçº¦éƒ¨ç½²æ™ºèƒ½åˆçº¦å¹¶ä¸å…¶äº¤äº’ã€‚


{% hint style="success" %}
ğŸ’¡ æœ¬æ•™ç¨‹çš„å®Œæ•´ä»£ç å¯ä»¥åœ¨ä»¥ä¸‹ä½ç½®æ‰¾åˆ°ï¼š

<https://github.com/CESSProject/cess-examples/tree/main/ink/nft_market>
{% endhint %}

# ç»“è®º

åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬äº†è§£äº† NFT æ˜¯ä»€ä¹ˆï¼Œä»¥åŠå¦‚ä½•ä½¿ç”¨ CESS æ¥å­˜å‚¨ NFT æ–‡ä»¶ã€‚æˆ‘ä»¬è¿˜å­¦ä¹ äº†å¦‚ä½•ä½¿ç”¨ openbrush æ¥å®æ–½ PSP34 ä»£å¸æ ‡å‡†ï¼Œä»¥åŠåœ¨ NFT äº¤æ˜“å¸‚åœºåº”ç”¨ç¨‹åºä¸­æ„å»ºå’Œä½¿ç”¨ ink! åˆçº¦çš„æ–¹å¼ï¼Œä»¥åŠä½¿ç”¨æˆ·èƒ½å¤Ÿé“¸é€ å’Œé”€å”®å…¶ NFT çš„æœ€åŸºæœ¬åŠŸèƒ½ã€‚

# ä¸‹ä¸€æ­¥æ˜¯ä»€ä¹ˆï¼Ÿ

åœ¨ä¸‹ä¸€è¯¾ç¨‹ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹ æ„å»ºä¸€ä¸ªå‰ç«¯ã€‚è¯¥å‰ç«¯å°†ä¸æˆ‘ä»¬çš„æ™ºèƒ½åˆçº¦äº¤äº’ï¼Œå¹¶ä½¿ç”¨æˆ·èƒ½å¤Ÿä¸Šä¼ ã€å‡ºå”®å’Œè´­ä¹° NFTã€‚

# å‚è€ƒ

- <https://use.ink/smart-contracts-polkadot/>
- <https://spin.atomicobject.com/2021/08/16/reentrancy-guard-smart-contracts/>
